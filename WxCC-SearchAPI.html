<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WxCC Search API</title>
  <link rel="icon" type="image/png" href="CX%20only.png" />
  <style>
    :root {
      --bg:#0b1020;
      --card:#131a2a;
      --muted:#92a0b8;
      --text:#e9edf5;
      --accentA:#22d3ee;
      --accentB:#3b82f6;
      --input:#0e1525;
      --border:rgba(255,255,255,.08);
      --radius:18px;
      --shadow:0 10px 30px rgba(0,0,0,.25);
    }
    *, *::before, *::after { box-sizing:border-box; }
    body { margin:0; min-height:100vh; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); color:var(--text); }
    header.banner { border-bottom:1px solid var(--border); padding:16px 20px; background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,0)); }
    .wrap { max-width:1280px; margin:0 auto; padding:0 18px; }
    .nav { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .brand { font-weight:800; font-size:1.1rem; letter-spacing:.25px; }
    .sub { display:none; }
    .btn { display:inline-flex; align-items:center; gap:8px; padding:9px 14px; border-radius:12px; font-weight:700; border:1px solid var(--border); background:var(--card); color:#e9edf5; text-decoration:none; cursor:pointer; }
    .btn.primary { background:linear-gradient(135deg,var(--accentA),var(--accentB)); color:#06111d; border:none; }
    .authLink.authed { background:linear-gradient(135deg,var(--accentA),var(--accentB)); color:#06111d; border:none; }
    .orgPane { display:none; }
    .orgTag { font-weight:800; color:var(--fg); font-size:16px; text-align:center; margin-top:10px; }
    .authFab { position:fixed; right:20px; bottom:20px; z-index:999; }

    main { padding:32px 0 80px; }
    .contentWrap { width:calc(100% - 24px); max-width:1280px; margin:0 auto; padding:0 12px; display:flex; flex-direction:column; gap:16px; }
    .layout { display:grid; grid-template-columns:500px 1fr; gap:16px; align-items:start; }
    .col { display:flex; flex-direction:column; gap:12px; }
    @media (max-width:1200px) { .layout { grid-template-columns:1fr; } }

    .card { position:relative; background:var(--card); border:1px solid var(--border); border-radius:var(--radius); padding:20px; box-shadow:var(--shadow); width:100%; }
    .section-title { display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:12px; font-size:15px; letter-spacing:.02em; color:var(--muted); text-transform:uppercase; }
    .org-title { margin:4px 0 10px; font-size:18px; font-weight:700; color:var(--text); letter-spacing:.01em; }
    .epoch-display { display:grid; gap:12px; grid-template-columns:repeat(auto-fit,minmax(320px,1fr)); }
    .epoch-row { display:flex; align-items:center; justify-content:space-between; gap:10px; padding:12px 14px; border-radius:12px; background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06); }
    .epoch-label { font-size:14px; color:var(--muted); }
    .epoch-value { font-variant-numeric:tabular-nums; font-weight:600; font-size:26px; letter-spacing:0.03em; }
    .range-bar { margin-top:14px; display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end; justify-content:space-between; }
    .range-group { display:flex; flex-direction:column; gap:8px; }
    .fetch-group { display:flex; align-items:flex-end; gap:10px; }
    .search-row { margin-top:12px; display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    .toggle-note { font-size:12px; color:var(--muted); }
    .utilityBar { display:flex; align-items:center; justify-content:flex-end; gap:10px; margin:4px 0 2px; }
    .search-toggle { border:1px solid var(--border); background:var(--input); color:var(--text); padding:8px 12px; border-radius:12px; cursor:pointer; font-weight:700; display:inline-flex; align-items:center; gap:8px; box-shadow:var(--shadow); }
    .search-toggle .dot { width:10px; height:10px; border-radius:999px; background:var(--muted); transition:background-color .2s ease, transform .2s ease; }
    .search-toggle.active { background:linear-gradient(135deg,var(--accentA),var(--accentB)); color:#06111d; border-color:rgba(59,130,246,0.9); }
    .search-toggle.active .dot { background:#06111d; transform:scale(1.05); }

    .controls { display:grid; gap:10px; }
    .control-row { display:grid; gap:8px; }
    .control-label { color:var(--muted); font-size:14px; letter-spacing:0.01em; }
    .button-row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }

    button.action { background:linear-gradient(135deg,var(--accentA),var(--accentB)); border:none; color:#06111d; padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:700; letter-spacing:0.01em; transition:opacity .15s ease; }
    button.action.secondary { background:var(--input); color:var(--text); border:1px solid var(--border); }
    button.action:hover { opacity:.9; }
    button.action:active { opacity:.8; }
    .range-btn.active { background:linear-gradient(135deg,var(--accentA),var(--accentB)) !important; color:#06111d !important; border:1px solid rgba(59,130,246,0.9) !important; box-shadow:0 10px 26px rgba(0,0,0,.25),0 0 0 3px rgba(59,130,246,.22); font-weight:700; letter-spacing:.01em; }

    input[type="number"], input[type="datetime-local"], input[type="text"], input[type="password"], select {
      background:var(--input);
      border:1px solid var(--border);
      color:var(--text);
      padding:10px 12px;
      border-radius:10px;
      font-size:15px;
      min-width:140px;
      appearance:none;
      -webkit-appearance:none;
      -moz-appearance:none;
    }
    select { cursor:pointer; background-image: linear-gradient(45deg, transparent 50%, var(--muted) 50%), linear-gradient(135deg, var(--muted) 50%, transparent 50%); background-position: calc(100% - 14px) calc(50% - 3px), calc(100% - 8px) calc(50% - 3px); background-size: 6px 6px, 6px 6px; background-repeat:no-repeat; padding-right:28px; }
    input:focus, textarea:focus { outline:2px solid rgba(59,130,246,.25); }
    textarea { width:100%; min-height:285px; background:var(--input); border:1px solid var(--border); color:var(--text); padding:10px 12px; border-radius:10px; font-size:15px; resize:vertical; font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace; line-height:1.4; }
    textarea::placeholder { color:var(--muted); opacity:1; }

    .copy-btn { background:rgba(34,211,238,0.12); border:1px solid rgba(34,211,238,0.4); color:var(--text); border-radius:10px; padding:8px 10px; cursor:pointer; font-weight:600; }

    .meta { display:flex; flex-wrap:wrap; gap:8px 14px; color:var(--muted); font-size:14px; }
    .tag { display:inline-flex; align-items:center; background:transparent; border:none; padding:0; border-radius:0; font-size:13px; color:var(--muted); }

    .response { background:var(--input); border:1px solid var(--border); border-radius:10px; padding:12px; color:var(--text); font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace; white-space:pre-wrap; min-height:180px; resize:vertical; overflow:auto; }
    .field-row { display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:10px; }
    .pathList { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
    .pathBadge { padding:6px 10px; border-radius:10px; background:rgba(255,255,255,.06); border:1px solid var(--border); font-size:12px; color:var(--text); cursor:pointer; transition:background-color .15s ease, border-color .15s ease; }
    .pathBadge:hover { background:rgba(255,255,255,.1); border-color:rgba(255,255,255,.15); }

    .collapseHead { display:flex; justify-content:space-between; gap:12px; align-items:flex-start; }
    .collapseBody { border-top:none; margin-top:0; padding-top:0; display:block; }

    .toolbar { display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between; }
    .toolbar-left { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .toolbar-right { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .toolbar-right input { flex:1; min-width:220px; }
    #presetSelect { min-width:260px; }
    .icon-btn { background:var(--input); border:1px solid var(--border); color:var(--text); border-radius:10px; padding:8px 14px; cursor:pointer; display:inline-flex; align-items:center; justify-content:center; min-width:80px; }
    .icon-btn svg { width:16px; height:16px; }
    .copy-input { position:relative; flex:1; }
    .copy-input input { width:100%; min-height:42px; height:42px; line-height:42px; padding-right:48px; }
    .copy-input .copy-fab { position:absolute; right:8px; top:50%; transform:translateY(-50%); }
    .copy-stack { display:flex; flex-direction:column; align-items:flex-end; gap:6px; margin-top:8px; }
    .copy-label { font-size:12px; color:var(--muted); }
    .response-wrap { position:relative; }
    .response-wrap { position:relative; }
    .response-wrap .response { padding-right:48px; margin:0; }
    .copy-fab { position:absolute; top:8px; right:8px; padding:0; background:transparent; border:none; border-radius:6px; width:32px; height:32px; min-width:32px; display:flex; align-items:center; justify-content:center; color:var(--muted); }
    .copy-fab:hover { color:var(--text); background:rgba(255,255,255,0.05); }
    .divider { border-top:1px solid rgba(255,255,255,.08); margin:12px 0; }
    .auth-help { margin-top:6px; text-align:right; }
    .auth-help a { color:var(--text); text-decoration:underline; font-weight:600; }

    @media (max-width:1024px) { .navWrap { grid-template-columns:1fr; text-align:center; } .navWrap .left, .navWrap .right { justify-self:center; } }
  </style>
</head>
<body>
  <header class="banner">
    <div class="wrap nav">
      <div>
        <div class="brand">WxCC Search API</div>
        <div class="orgTag" id="orgTag">Not authenticated</div>
      </div>
      <div class="row" style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        <a class="btn" href="index.html" aria-label="Home" title="Home" style="gap:6px; align-items:center;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle;">
            <path d="M3 11.5 12 4l9 7.5"/>
            <path d="M5 10v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V10"/>
            <path d="M10 21v-6h4v6"/>
          </svg>
        </a>
        <a class="btn" href="WxCC.html">← Back to WxCC tools</a>
        <a class="btn primary" href="https://developer.webex.com/webex-contact-center/docs/webex-contact-center" target="_blank" rel="noreferrer">Webex CC API Docs</a>
      </div>
    </div>
  </header>

  <main>
    <div class="contentWrap">
      <div class="layout">
        <div class="col">
          <section class="card">
            <div class="section-title">
              <span>Epoch window</span>
            </div>
            <div class="epoch-display">
              <div class="epoch-row">
                <div>
                  <div class="epoch-label">FROM</div>
                  <div class="epoch-value" id="fromMs">--</div>
                  <div class="epoch-label" id="fromLocal">--</div>
                </div>
                <button class="copy-btn" data-copy="from">Copy</button>
              </div>
              <div class="epoch-row">
                <div>
                  <div class="epoch-label">TO</div>
                  <div class="epoch-value" id="toMs">--</div>
                  <div class="epoch-label" id="toLocal">--</div>
                </div>
                <button class="copy-btn" data-copy="to">Copy</button>
              </div>
            </div>
            <div class="range-bar">
              <div class="range-group">
                <div class="control-label">Pick a window</div>
                <div class="button-row compact">
                  <button class="action secondary range-btn" data-range="600000">10m</button>
                  <button class="action secondary range-btn" data-range="3600000">1h</button>
                  <button class="action secondary range-btn" data-range="86400000">24h</button>
                  <button class="action secondary range-btn" data-range="604800000">7d</button>
                </div>
              </div>
              <div class="fetch-group">
                <button class="action" id="fetchNow" style="min-width:110px;">Fetch</button>
              </div>
            </div>
          </section>

          <section class="card" id="parseCard">
            <div class="section-title" style="margin-bottom: 6px;">
              <span>Parse Tester</span>
            </div>
            <div class="controls">
              <div class="control-row">
                <div class="control-label">Try parsing the response below</div>
                <div class="toolbar">
                  <div class="toolbar-right" style="flex:1; justify-content:flex-start;">
                    <div class="copy-input">
                      <input type="text" id="parsePath" placeholder="$.data" aria-label="Parse path" style="min-width:260px;">
                      <button class="icon-btn copy-fab" data-copy-target="parsePath" title="Copy parse path" aria-label="Copy parse path" style="width:32px;height:32px;">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                          <rect x="9" y="9" width="13" height="13" rx="2"></rect>
                          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                        </svg>
                      </button>
                    </div>
                    <button class="action secondary" id="parseBtn">Extract</button>
                  </div>
                </div>
                <div class="pathList" id="pathList"></div>
              <div class="response-wrap" style="margin-top:6px;">
                <button class="icon-btn copy-fab" data-copy-target="parseResult" title="Copy parse result" aria-label="Copy parse result">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <rect x="9" y="9" width="13" height="13" rx="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                  </svg>
                  </button>
                  <pre class="response" id="parseResult">Result will appear here…</pre>
                </div>
              </div>
            </div>
          </section>
        </div>

        <div class="col">
          <section class="card" id="searchCard">
            <div class="collapseBody">
              <div class="controls">
                <div class="control-row">
                  <div class="toolbar">
                    <div class="toolbar-left">
                      <select id="presetSelect" aria-label="Preset query"></select>
                      <button class="action secondary" id="previewPreset">Preview</button>
                      <button class="action secondary" id="loadPreset">Load</button>
                    </div>
                    <div class="toolbar-right">
                      <button class="action secondary" id="updateWindow">Update EPOCH Time</button>
                      <button class="action" id="runSearch">SEND</button>
                    </div>
                  </div>
                </div>
                <div class="control-row">
                  <div class="control-label">Request body (GraphQL)</div>
                  <div class="response-wrap">
                    <button class="icon-btn copy-fab" data-copy-target="searchBody" title="Copy request body" aria-label="Copy request body">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <rect x="9" y="9" width="13" height="13" rx="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                    </button>
                    <textarea id="searchBody"></textarea>
                  </div>
                </div>
                <div class="control-row" style="text-align:right; margin-top:-4px;">
                  <span class="tag" id="searchStatus">Idle</span>
                </div>
                <div class="control-row" style="margin-top:32px;">
                  <div class="control-label">Response</div>
                </div>
                <div class="control-row" style="margin-top:0;">
                  <div class="control-label" style="display:none;">Response</div>
                  <div class="response-wrap">
                    <button class="icon-btn copy-fab" id="copyResponse" title="Copy response" aria-label="Copy response">
                      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                        <rect x="9" y="9" width="13" height="13" rx="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                    </button>
                    <pre class="response" id="searchOutput">Waiting to call API…</pre>
                  </div>
                </div>
              </div>
            </div>
          </section>
        </div>
      </div>
    </div>
  </main>
  <button class="btn authLink authFab" aria-label="Authenticate">Authenticate</button>
  <script>
    const fromMsEl = document.getElementById('fromMs');
    const toMsEl = document.getElementById('toMs');
    const fromLocalEl = document.getElementById('fromLocal');
    const toLocalEl = document.getElementById('toLocal');
    const fetchNowBtn = document.getElementById('fetchNow');
    const searchCardEl = document.getElementById('searchCard');
    const searchStatusEl = document.getElementById('searchStatus');
    const searchOutputEl = document.getElementById('searchOutput');
    const runSearchBtn = document.getElementById('runSearch');
    const searchBodyEl = document.getElementById('searchBody');
    const loadPresetBtn = document.getElementById('loadPreset');
    const copyResponseBtn = document.getElementById('copyResponse');
    const presetSelect = document.getElementById('presetSelect');
    const previewPresetBtn = document.getElementById('previewPreset');
    const toggleSearchBtn = document.getElementById('toggleSearch');
    const updateWindowBtn = document.getElementById('updateWindow');
    const parsePathInput = document.getElementById('parsePath');
    const parseBtn = document.getElementById('parseBtn');
    const parseResultEl = document.getElementById('parseResult');
    const parseCardEl = document.getElementById('parseCard');
    const pathListEl = document.getElementById('pathList');

    const ENDPOINT = 'https://api.wxcc-us1.cisco.com/search';
    const cacheKeyBearer = 'authBearer';
    const cacheKeyOrg = 'authOrg';
    const cacheKeyOrgName = 'authOrgName';
    const cacheKeySearchVisible = 'epochSearchVisible';

    let selectedRangeMs = 600000; // default 10m
    let lastFetchMs = null;
    let fromMs = null;
    let toMs = null;
    let lastJson = null;

    const formatLocal = (ms, opts = {}) => {
      return new Intl.DateTimeFormat(undefined, {
        year: 'numeric',
        month: 'short',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: opts.ms ? 3 : undefined,
        timeZoneName: 'short'
      }).format(new Date(ms));
    };

    const highlightRangeButton = () => {
      document.querySelectorAll('.range-btn').forEach((btn) => {
        const val = Number(btn.dataset.range);
        const isActive = val === selectedRangeMs;
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-pressed', String(isActive));
      });
    };
    highlightRangeButton();

    const copyActions = {
      from: () => String(fromMs ?? ''),
      to: () => String(toMs ?? '')
    };

    const flashCopyState = (btn) => {
      const original = btn.textContent;
      btn.textContent = 'Copied';
      setTimeout(() => (btn.textContent = original), 900);
    };

    document.querySelectorAll('.copy-btn').forEach((btn) => {
      btn.addEventListener('click', async () => {
        const kind = btn.dataset.copy;
        const getter = copyActions[kind];
        if (getter) {
          const text = getter();
          try {
            await navigator.clipboard.writeText(text);
            flashCopyState(btn);
          } catch (err) {
            console.error('Copy failed', err);
          }
        }
      });
    });

    document.querySelectorAll('.range-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        const val = Number(btn.dataset.range);
        if (!Number.isNaN(val)) {
          selectedRangeMs = val;
          highlightRangeButton();
        }
      });
    });

    const updateDisplay = () => {
      if (fromMs !== null && toMs !== null) {
        fromMsEl.textContent = fromMs;
        toMsEl.textContent = toMs;
        fromLocalEl.textContent = formatLocal(fromMs, { ms: true });
        toLocalEl.textContent = formatLocal(toMs, { ms: true });
      }
    };

    // Search always visible; hide toggle (if present) and ensure shown
    if (toggleSearchBtn) toggleSearchBtn.style.display = 'none';
    searchCardEl.style.display = '';

    // Parse tester always visible
    if (parseCardEl) parseCardEl.style.display = '';

    // Simple path parser (dot/bracket notation) for response
    const parsePath = (obj, path) => {
      if (!path) return obj;
      const cleaned = path.replace(/^\s*\$\.?/, ''); // drop optional leading $
      const parts = cleaned
        .replace(/\[(\w+)\]/g, '.$1')
        .split('.')
        .filter(Boolean);
      return parts.reduce((curr, key) => (curr && key in curr ? curr[key] : undefined), obj);
    };

    const runParse = () => {
      const path = parsePathInput.value.trim();
      const raw = (searchOutputEl.textContent || '').trim();
      if (!raw) {
        parseResultEl.textContent = 'No response to parse yet.';
        return;
      }
      // Only try to parse when the response looks like JSON
      if (!raw.startsWith('{') && !raw.startsWith('[')) {
        parseResultEl.textContent = 'Response is not JSON yet.';
        return;
      }
      try {
        const json = JSON.parse(raw);
        const result = parsePath(json, path);
        const formatted =
          result === undefined ? 'Not found' : typeof result === 'object' ? JSON.stringify(result, null, 2) : String(result);
        parseResultEl.textContent = formatted;
      } catch (err) {
        parseResultEl.textContent = 'Response is not valid JSON yet.';
      }
    };

    parseBtn.addEventListener('click', runParse);
    parsePathInput.addEventListener('input', runParse);
    searchOutputEl.addEventListener('mouseup', () => {
      const sel = (window.getSelection()?.toString() || '').trim();
      if (sel && sel.length < 120) {
        parsePathInput.value = sel;
        parseBtn.click();
      }
    });

    const presets = [
      { key: 'simple', label: 'Simple: Task IDs', query: `{\n  task(\n    from: {{FROM}}\n    to: {{TO}}\n  ) {\n    tasks { id }\n  }\n}` },
      { key: 'basicFields', label: 'Basic Fields', query: `{\n  task(\n    from: {{FROM}}\n    to: {{TO}}\n    pagination: { cursor: "0" }\n  ) {\n    tasks {\n      createdTime\n      channelType\n      entryPoint { name }\n      lastQueue { name }\n      direction\n      terminationType\n      owner { name }\n      id\n      status\n      destination\n      isActive\n      selfserviceDuration\n      ringingDuration\n      queueDuration\n      connectedDuration\n      totalDuration\n      holdDuration\n      wrapupDuration\n    }\n    pageInfo { endCursor hasNextPage }\n  }\n}` },
      { key: 'realTimeQueuedTasks', label: 'Real-time Queued Tasks', query: `{\n  task(\n    from: {{FROM}}\n    to: {{TO}}\n    filter: {\n      and: [\n        { channelType: { equals: telephony } }\n        { direction: { equals: "inbound" } }\n        { isActive: { equals: true } }\n      ]\n    }\n  ) {\n    tasks {\n      id\n      origin\n      destination\n      isActive\n      direction\n      owner { id name }\n      lastEntryPoint { id name }\n    }\n  }\n}` },
      { key: 'advanced', label: 'Advanced Aggregates', query: `{\n  task(\n    from: {{FROM}}\n    to: {{TO}}\n    timeComparator: endedTime\n    filter: {\n      and: [\n        { channelType: { equals: telephony } }\n        { status: { equals: "ended" } }\n        { isActive: { equals: false } }\n      ]\n    }\n    aggregation: {\n      aggr: [\n        { field: totalDuration, type: sum, name: "Total Duration" }\n        { field: connectedDuration, type: sum, name: "Total Connected Duration" }\n      ]\n    }\n  ) {\n    tasks {\n      lastWrapupCodeName\n      aggregation { name value }\n    }\n    pageInfo { endCursor hasNextPage }\n  }\n}` },
      { key: 'callbackFilter', label: 'Callback Filter', query: `{\n  task(\n    from: {{FROM}}\n    to: {{TO}}\n     filter: {\n      and: [\n        { callbackData: { equals: { callbackNumber: "nnnnnnnnnnn" } } }\n        { callbackData: { equals: { callbackStatus: "Success" } } }\n      ]\n    }\n  ) {\n    tasks {\n      callbackData {\n        callbackRequestTime\n        callbackConnectTime\n        callbackNumber\n        callbackStatus\n        callbackOrigin\n        callbackType\n      }\n    }\n  }\n}` },
      { key: 'interactionDetails', label: 'Interaction Details', query: `{\n  task(\n    from: {{FROM}}\n    to: {{TO}}\n     timeComparator: createdTime\n    filter: {\n      and: [\n        { channelType: { equals: telephony } }\n        { origin: { equals: "+12345670000" } }\n      ]\n    }\n  ) {\n    tasks {\n      id\n      isActive\n      createdTime\n      endedTime\n      origin\n      destination\n      totalDuration\n      lastEntryPoint { id name }\n      lastQueue { id name }\n      lastTeam { id name }\n      owner { name id }\n    }\n  }\n}` },
      { key: 'lastAgentInteraction', label: 'Last Agent Interaction', query: `{\n  task(\n    from: {{FROM}}\n    to: {{TO}}\n    timeComparator: createdTime\n    filter: {\n      and: [\n        { channelType: { equals: telephony } }\n        { origin: { equals: "+12345677890" } }\n        { status: { equals: "ended" } }\n        { direction: { equals: "inbound" } }\n        { isActive: { equals: false } }\n      ]\n    }\n    pagination: { cursor: "0" }\n  ) {\n    tasks {\n      id\n      createdTime\n      endedTime\n      origin\n      destination\n      lastWrapupCodeName\n      totalDuration\n      selfserviceDuration\n      captureRequested\n      lastEntryPoint { id name }\n      lastQueue { id name }\n      lastTeam { id name }\n      owner { name id }\n    }\n    pageInfo { endCursor hasNextPage }\n  }\n}` },
      { key: 'agentSessionState', label: 'Agent Session State', query: `{\n  agentSession(\n    from: {{FROM}}\n    to: {{TO}}\n    filter: { isActive: { equals: true } }\n  ) {\n    agentSessions {\n      agentName\n    }\n  }\n}` },
      { key: 'wallboardQueue', label: 'Wallboard: Queue Metrics', query: `{\n  task(\n    from: {{FROM}}\n    to: {{TO}}\n    timeComparator: createdTime\n    filter: {\n      and: [\n        { direction: { equals: "inbound" } }\n        { channelType: { equals: telephony } }\n      ]\n    }\n    aggregations: [\n      { field: "id", type: count, name: "Total Contacts by Queue" }\n      { field: "queueDuration", type: average, name: "Average Queue Time" }\n      { field: "queueDuration", type: max, name: "Maximum Queue Time" }\n      { field: "totalDuration", type: average, name: "Average Handle Time by Queue" }\n    ]\n  ) {\n    tasks {\n      lastQueue { name id }\n      aggregation { name value }\n    }\n    pageInfo { hasNextPage endCursor }\n  }\n}` },
      { key: 'queueRealtime', label: 'Realtime Queued Count', query: `{\n  task(\n    from: {{FROM}}\n    to: {{TO}}\n    timeComparator: createdTime\n    filter: {\n      and: [\n        { direction: { equals: "inbound" } }\n        { isActive: { equals: true } }\n        { status: { equals: "parked" } }\n        { channelType: { equals: telephony } }\n      ]\n    }\n    aggregations: {\n      field: "id"\n      type: count\n      name: "Total Queued Contacts RealTime"\n    }\n  ) {\n    tasks {\n      aggregation { name value }\n    }\n    pageInfo { hasNextPage endCursor }\n  }\n}` },
      { key: 'AgentsLogin', label: 'Realtime Agents Logged In', query: `{\n  agentSession(\n    from: {{FROM}}\n    to: {{TO}}\n    filter: { isActive: { equals: true } }\n  ) {\n    agentSessions { agentId teamId }\n  }\n}` },
      { key: 'loggedOnAgents', label: 'Logged On agents', query: `{\n  agentSession(\n    from: {{FROM}}\n    to: {{TO}}\n    filter: {\n      and: [\n        { isActive: { equals: true } }\n        { teamId: { equals: "ee1247b5-b313-4455-985a-fe3a299f806d" } }\n      ]\n    }\n  ) {\n    agentSessions {\n      agentName\n      teamName\n      channelInfo {\n        channelType\n        connectedCount\n        availableCount\n        idleCount\n      }\n    }\n  }\n}` },
    ];

    const fillPresetSelect = () => {
      presetSelect.innerHTML = '';
      const empty = document.createElement('option');
      empty.value = '';
      empty.textContent = 'Select a preset';
      presetSelect.appendChild(empty);
      presets.forEach((p) => {
        const opt = document.createElement('option');
        opt.value = p.key;
        opt.textContent = p.label;
        presetSelect.appendChild(opt);
      });
    };
    fillPresetSelect();

    const autosizeTextarea = () => {
      if (!searchBodyEl) return;
      searchBodyEl.style.height = 'auto';
      searchBodyEl.style.height = `${Math.max(searchBodyEl.scrollHeight, 285)}px`;
    };

    const applyEpochToQuery = (query) => {
      const from = fromMs ?? Date.now() - selectedRangeMs;
      const to = toMs ?? Date.now();
      return query.replace(/{{FROM}}/g, from).replace(/{{TO}}/g, to);
    };

    const loadPreset = () => {
      const key = presetSelect.value;
      const preset = presets.find((p) => p.key === key);
      if (preset) {
        refreshEpochWindow({ updateBody: true, presetKey: key });
        searchStatusEl.textContent = `Loaded preset: ${preset.label}`;
      }
    };

    const DEFAULT_BODY = `{
  task(
    from: {{FROM}}
    to: {{TO}}
  ) {
    tasks { id }
  }
}`;

    const buildDefaultSearchBody = () => applyEpochToQuery(DEFAULT_BODY);

    const refreshEpochWindow = ({ updateBody = false, presetKey } = {}) => {
      const now = Date.now();
      toMs = now;
      fromMs = now - selectedRangeMs;
      lastFetchMs = now;
      updateDisplay();

      const example = buildDefaultSearchBody();
      searchBodyEl.placeholder = example;

      if (updateBody) {
        const currentVal = searchBodyEl.value.trim();
        const presetTemplate = (() => {
          if (!presetKey) return '';
          const preset = presets.find((p) => p.key === presetKey);
          return preset ? preset.query : '';
        })();

        const hasPlaceholders = /{{FROM}}|{{TO}}/.test(currentVal);
        const templateFromDataset = searchBodyEl.dataset.template || '';

        let template = presetTemplate || (hasPlaceholders ? currentVal : templateFromDataset);

        // If we still don't have a template, try to derive one by swapping the current epoch numbers with placeholders
        if (!template) {
          template = currentVal
            .replace(/(from:\s*)\d+/i, '$1{{FROM}}')
            .replace(/(to:\s*)\d+/i, '$1{{TO}}');
        }

        if (!template.trim()) template = DEFAULT_BODY;

        // Store the template so future updates can re-inject new epoch values even after they were replaced
        searchBodyEl.dataset.template = template;

        searchBodyEl.value = applyEpochToQuery(template);
        delete searchBodyEl.dataset.example;
      }
      autosizeTextarea();

      const orgName = localStorage.getItem(cacheKeyOrgName) || '';
      const orgId = localStorage.getItem(cacheKeyOrg) || '';
      const tag = document.getElementById('orgTag');
      if (tag) tag.textContent = orgName ? `Org: ${orgName}` : (orgId ? `Org: ${orgId}` : 'Not authenticated');
    };

    // Refresh time window and inject into body
    updateWindowBtn.addEventListener('click', () => {
      refreshEpochWindow({ updateBody: true });
      searchStatusEl.textContent = 'Window updated';
    });

    fetchNowBtn.addEventListener('click', () => {
      refreshEpochWindow({ updateBody: false });
    });

    runSearchBtn.addEventListener('click', async () => {
      const bearer = (localStorage.getItem(cacheKeyBearer) || '').trim();
      const orgId = (localStorage.getItem(cacheKeyOrg) || '').trim();
      if (!bearer || !orgId) {
        searchStatusEl.textContent = 'Missing bearer token or Org ID — click Authenticate.';
        return;
      }

      const gql = (searchBodyEl.value.trim() || buildDefaultSearchBody()).trim();
      const bodyObj = { query: gql, variables: {} };
      const body = JSON.stringify(bodyObj);

      searchStatusEl.textContent = 'Calling…';
      searchOutputEl.textContent = 'Calling API with body:\n' + body;

      const headers = {
        Authorization: `Bearer ${bearer}`,
        OrgId: orgId
      };

      headers['Content-Type'] = 'application/json';

      try {
        const res = await fetch(ENDPOINT, {
          method: 'POST',
          headers,
          body
        });
        const text = await res.text();
        let formatted = text || '(empty response)';
        try {
          const parsed = JSON.parse(text);
          formatted = JSON.stringify(parsed, null, 2);
          lastJson = parsed;
          renderPaths();
        } catch (_) {
          // keep raw text
          lastJson = null;
          renderPaths();
        }
        searchStatusEl.textContent = res.ok ? 'Success' : `Error (${res.status})`;
        searchOutputEl.textContent = formatted;
      } catch (err) {
        searchStatusEl.textContent = 'Network/connection error';
        searchOutputEl.textContent = `Fetch failed:\n${String(err)}\n\nPayload sent:\n${body}`;
        lastJson = null;
        renderPaths();
      }
    });

    loadPresetBtn.addEventListener('click', () => {
      loadPreset();
    });

    searchBodyEl.addEventListener('input', autosizeTextarea);

    const openPresetPreview = () => {
      const key = presetSelect.value;
      const preset = presets.find((p) => p.key === key);
      const text = preset ? applyEpochToQuery(preset.query) : 'Select a preset first.';

      let overlay = document.getElementById('presetPreviewModal');
      if (!overlay) {
        const style = document.createElement('style');
        style.textContent = `
          .presetOverlay{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:9998;padding:16px;}
          .presetOverlay.open{display:flex;}
          .presetCard{width:100%;max-width:720px;background:#131a2a;border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:18px;box-shadow:0 18px 36px rgba(0,0,0,.45);position:relative;}
          .presetCard h3{margin:0 0 8px;font-size:1.05rem;}
          .presetClose{position:absolute;right:10px;top:10px;background:transparent;border:none;color:#92a0b8;font-size:18px;cursor:pointer;}
          .presetBody{background:var(--input);border:1px solid var(--border);border-radius:12px;padding:12px;color:var(--text);font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace;white-space:pre-wrap;max-height:60vh;overflow:auto;}
        `;
        document.head.appendChild(style);
        overlay = document.createElement('div');
        overlay.className = 'presetOverlay';
        overlay.id = 'presetPreviewModal';
        overlay.innerHTML = `
          <div class="presetCard">
            <button class="presetClose" aria-label="Close">×</button>
            <h3>Preset preview</h3>
            <pre class="presetBody" id="presetPreviewBody"></pre>
          </div>
        `;
        document.body.appendChild(overlay);
        overlay.addEventListener('click', (e)=>{ if (e.target === overlay) overlay.classList.remove('open'); });
        overlay.querySelector('.presetClose').addEventListener('click', ()=> overlay.classList.remove('open'));
        window.addEventListener('keydown',(e)=>{ if (e.key === 'Escape') overlay.classList.remove('open'); });
      }

      const body = overlay.querySelector('#presetPreviewBody');
      if (body) body.textContent = text;
      overlay.classList.add('open');
    };

    if (previewPresetBtn) {
      previewPresetBtn.addEventListener('click', () => {
        openPresetPreview();
      });
    }

    copyResponseBtn.addEventListener('click', async () => {
      const text = searchOutputEl.textContent || '';
      const original = copyResponseBtn.innerHTML;
      try {
        await navigator.clipboard.writeText(text);
        copyResponseBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 13l4 4L19 7"></path></svg>';
        setTimeout(() => (copyResponseBtn.innerHTML = original), 900);
      } catch (err) {
        console.error('Copy failed', err);
      }
    });

    // Generic copy for elements with data-copy-target
    document.querySelectorAll('[data-copy-target]').forEach((btn) => {
      btn.addEventListener('click', async () => {
        const targetId = btn.getAttribute('data-copy-target');
        const target = document.getElementById(targetId);
        if (!target) return;
        const text = target.value !== undefined ? target.value : target.textContent || '';
        const original = btn.innerHTML;
        try {
          await navigator.clipboard.writeText(text);
          btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 13l4 4L19 7"></path></svg>';
          setTimeout(() => (btn.innerHTML = original), 900);
        } catch (err) {
          console.error('Copy failed', err);
        }
      });
    });

    // Auth modal shared
    (function initAuthModal(){
      if (document.getElementById('authModal')) return;
      const style = document.createElement('style');
      style.textContent = `
        .authModalOverlay{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:9999;padding:16px;}
        .authModalOverlay.open{display:flex;}
        .authCard{width:100%;max-width:520px;background:#131a2a;border:1px solid rgba(255,255,255,.08);border-radius:16px;padding:18px;box-shadow:0 18px 36px rgba(0,0,0,.45);position:relative;}
        .authCard h2{margin:0 0 8px;font-size:1.2rem;}
        .authCard p{margin:0 0 12px;color:#92a0b8;line-height:1.4;}
        .authCard label{display:block;font-size:13px;color:#92a0b8;margin:10px 0 6px;}
        .authCard input{width:100%;border-radius:12px;border:1px solid rgba(255,255,255,.08);background:#0e1525;color:#e9edf5;padding:10px 12px;font-size:14px;}
        .authCard input:focus{outline:none;box-shadow:0 0 0 3px rgba(59,130,246,.25);}
        .authCard .actions{display:flex;gap:10px;justify-content:flex-end;margin-top:14px;}
        .authCard .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:9px 14px;border-radius:12px;font-weight:700;border:1px solid rgba(255,255,255,.08);background:#0e1525;color:#e9edf5;cursor:pointer;text-decoration:none;}
        .authCard .btn.primary{background:linear-gradient(135deg,#22d3ee,#3b82f6);color:#06111d;border:none;}
        .authClose{position:absolute;right:10px;top:10px;background:transparent;border:none;color:#92a0b8;font-size:18px;cursor:pointer;}
        .authStatus{margin-top:8px;font-size:13px;color:#92a0b8;}
      `;
      document.head.appendChild(style);

      const overlay = document.createElement('div');
      overlay.className = 'authModalOverlay';
      overlay.id = 'authModal';
      overlay.innerHTML = `
        <div class="authCard">
          <button class="authClose" aria-label="Close">×</button>
          <h2>Authenticate</h2>
          <p>Paste your Bearer token and Org ID. Saved locally for all tools.</p>
          <label for="authBearer">Bearer token</label>
          <input id="authBearer" type="password" autocomplete="off" placeholder="Paste Bearer token" />
          <label for="authOrg">Org ID</label>
          <input id="authOrg" type="text" autocomplete="off" placeholder="Paste Org ID" />
          <div class="actions">
            <a class="btn" href="https://developer.webex.com/docs/api/getting-started" target="_blank" rel="noreferrer">Get token</a>
            <button class="btn primary" id="authSave">Save</button>
          </div>
          <div class="authStatus" id="authStatus"></div>
        </div>
      `;
      document.body.appendChild(overlay);

      const bearerEl = overlay.querySelector('#authBearer');
      const orgEl = overlay.querySelector('#authOrg');
      const statusEl = overlay.querySelector('#authStatus');
      const closeBtn = overlay.querySelector('.authClose');
      const saveBtn = overlay.querySelector('#authSave');
      const KEYS = { bearer:'authBearer', org:'authOrg', orgName:'authOrgName' };

      const populate = ()=> {
        bearerEl.value = localStorage.getItem(KEYS.bearer) || '';
        orgEl.value = localStorage.getItem(KEYS.org) || '';
        statusEl.textContent = localStorage.getItem(KEYS.orgName) ? `Org: ${localStorage.getItem(KEYS.orgName)}` : '';
      };

      const fetchOrgName = async (bearer, orgId) => {
        try {
          const res = await fetch(`https://webexapis.com/v1/organizations/${encodeURIComponent(orgId)}`, { headers:{Authorization:`Bearer ${bearer}`}});
          const data = await res.json();
          return data.displayName || data.name || data.organization?.displayName || data.organization?.name || orgId;
        } catch { return ''; }
      };

      saveBtn.addEventListener('click', async ()=>{
        const b = bearerEl.value.trim();
        const o = orgEl.value.trim();
        localStorage.setItem(KEYS.bearer, b);
        localStorage.setItem(KEYS.org, o);
        statusEl.textContent = 'Saved';
        if (b && o) {
          statusEl.textContent = 'Looking up org...';
          const name = await fetchOrgName(b, o);
          if (name) {
            localStorage.setItem(KEYS.orgName, name);
            statusEl.textContent = `Saved — Org: ${name}`;
          } else {
            statusEl.textContent = 'Saved (org lookup failed)';
          }
        }
        const orgTag = document.getElementById('orgTag');
        const name = localStorage.getItem(KEYS.orgName) || '';
        if (orgTag) orgTag.textContent = name ? `Org: ${name}` : (o ? `Org: ${o}` : 'Not authenticated');
        updateAuthIndicators();
        setTimeout(()=>{ overlay.classList.remove('open'); }, 1200);
      });

      const close = ()=> overlay.classList.remove('open');
      closeBtn.addEventListener('click', close);
      overlay.addEventListener('click',(e)=>{ if (e.target === overlay) close(); });
      window.addEventListener('keydown',(e)=>{ if (e.key === 'Escape') close(); });

      const open = ()=> { populate(); overlay.classList.add('open'); };
      document.querySelectorAll('.authLink').forEach(el=>{
        el.addEventListener('click',(e)=>{ e.preventDefault(); open(); });
      });
    })();

    function updateAuthIndicators() {
      const b = localStorage.getItem('authBearer') || '';
      const org = localStorage.getItem('authOrgName') || localStorage.getItem('authOrg') || '';
      document.querySelectorAll('.authLink').forEach(el=>{
        if (b) { el.classList.add('authed'); el.textContent = 'Authenticated'; }
        else { el.classList.remove('authed'); el.textContent = 'Authenticate'; }
      });
      const tag = document.getElementById('orgTag');
      if (tag) tag.textContent = org ? `Org: ${org}` : 'Not authenticated';
    }
    updateAuthIndicators();

    const renderPaths = () => {
      if (!pathListEl) return;
      pathListEl.innerHTML = '';
      if (!lastJson || typeof lastJson !== 'object') return;
      const paths = [];
      const MAX_PATHS = 40;
      const MAX_DEPTH = 8; // allow nested array/object hops (e.g., ...[0].aggregation[0].value)
      const add = (p) => { if (paths.length < MAX_PATHS) paths.push(p); };
      const queue = [['$', lastJson, 0]];
      while (queue.length && paths.length < MAX_PATHS) {
        const [p, val, depth] = queue.shift();
        if (depth > MAX_DEPTH) continue;
        if (Array.isArray(val)) {
          add(p);
          if (val[0] !== undefined) queue.push([`${p}[0]`, val[0], depth + 1]);
        } else if (val && typeof val === 'object') {
          add(p);
          Object.keys(val).slice(0, 6).forEach((k) => queue.push([`${p}.${k}`, val[k], depth + 1]));
        } else {
          // primitives/null — surface full path to values like ".name" or ".value"
          add(p);
        }
      }
      paths.forEach(p => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'pathBadge';
        btn.textContent = p;
        btn.addEventListener('click', () => {
          parsePathInput.value = p;
          parseBtn.click();
        });
        pathListEl.appendChild(btn);
      });
    };

    // Initial state
    fetchNowBtn.click();
    autosizeTextarea();
  </script>
</body>
</html>
